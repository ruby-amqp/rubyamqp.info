<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head>
  <title>
    Ruby amqp gem:
    Working with exchanges
  </title>
  <link href='/assets/stylesheets/sass/styles.css' media='screen' rel='stylesheet' type='text/css' />
</head>
<script src='/assets/javascripts/jquery-1.7.min.js' type='text/javascript'></script>
<script src='/assets/javascripts/codemirror.js'></script>
<script src='/assets/javascripts/toc.js'></script>
<script src='/assets/javascripts/code_highlight.js'></script>
<link href='/assets/stylesheets/codemirror.css' rel='stylesheet' />
<script src='/assets/javascripts/mode/ruby.js'></script>
<link href='/assets/stylesheets/theme/default.css' rel='stylesheet' />
<script type='text/javascript'>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27153041-1']);
  _gaq.push(['_trackPageview']);
  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script><body><div class='topbar'>
  <div class='topbar-inner'>
    <div class='container'>
      <ul class='nav'>
        <li>
          <a href='/'>
            Home
          </a>
        </li>
        <li>
          <a href='/articles/getting_started/'>
            Getting Started
          </a>
        </li>
        <li>
          <a href='/articles/amqp_9_1_model_explained/'>
            AMQP 0.9.1 Model
          </a>
        </li>
        <li>
          <a href='/articles/connecting_to_broker/'>
            Connecting
          </a>
        </li>
        <li>
          <a href='/articles/working_with_queues/'>
            Queues
          </a>
        </li>
        <li>
          <a href='/articles/working_with_exchanges/'>
            Exchanges
          </a>
        </li>
        <li>
          <a href='/articles/patterns_and_use_cases/'>
            Patterns & Use Cases
          </a>
        </li>
        <li>
          <a href='/articles/error_handling/'>
            Error Handling
          </a>
        </li>
      </ul>
    </div>
  </div>
</div><section class='content'><article><div class='toc'></div>
<h1>Working with exchanges</h1>
<h2>About this guide</h2>
<p>This guide covers the use of exchanges according to the <span class="caps">AMQP</span> v0.9.1 specification including message publishing, common usage scenarios and how to accomplish typical operations using the Ruby amqp gem. This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a> (including images &amp; stylesheets). The source is available <a href="https://github.com/ruby-amqp/amqp/tree/master/docs">on Github</a>.</p>
<h2>Which versions of the amqp gem does this guide cover?</h2>
<p>This guide covers v0.8.0 and later of the <a href="http://github.com/ruby-amqp/amqp">Ruby amqp gem</a>.</p>
<h2>Exchanges in <span class="caps">AMQP</span> v0.9.1 &#8211; overview</h2>
<h3>What are <span class="caps">AMQP</span> exchanges?</h3>
<p>An <span class="note">exchange</span> accepts messages from a producer application and routes them to message queues. They can be thought of as the &#8220;mailboxes&#8221; of the <span class="caps">AMQP</span> world. Unlike some other messaging middleware products and protocols, in <span class="caps">AMQP</span>, messages are <strong>not</strong> published directly to queues. Messages are published to exchanges that route them to queue(s) using pre-arranged criteria called <span class="note">bindings</span>.</p>
<p>There are multiple exchange types in the <span class="caps">AMQP</span> v0.9.1 specification, each with its own routing semantics. Custom exchange types can be created to deal with sophisticated routing scenarios (e.g. routing based on geolocation data or edge cases) or just for convenience.</p>
<h3>Concept of bindings</h3>
<p>A <span class="note">binding</span> is an association between a queue and an exchange. A queue must be bound to at least one exchange in order to receive messages from publishers. Learn more about bindings in the <a href="/articles/bindings/">Bindings guide</a>.</p>
<h3>Exchange attributes</h3>
<p>Exchanges have several attributes associated with them:</p>
<ul>
	<li>Name</li>
	<li>Type (direct, fanout, topic, headers or some custom type)</li>
	<li>Durability</li>
	<li>Whether the exchange is auto-deleted when no longer used</li>
	<li>Other metadata (sometimes known as <span class="note">X-arguments</span>)</li>
</ul>
<h2>Exchange types</h2>
<p>There are 4 built-in exchange types in <span class="caps">AMQP</span> v0.9.1:</p>
<ul>
	<li>Direct</li>
	<li>Fanout</li>
	<li>Topic</li>
	<li>Headers</li>
</ul>
<p>As stated previously, each exchange type has its own routing semantics and new exchange types can be added by extending brokers with plugins. Custom exchange types begin with &#8220;x-&#8221;, much like custom <span class="caps">HTTP</span> headers, e.g. <a href="https://github.com/videlalvaro/rabbitmq-recent-history-exchange">x-recent-history exchange</a> or <a href="https://github.com/jbrisbin/random-exchange">x-random exchange</a>.</p>
<h2>Message attributes</h2>
<p>Before we start looking at various exchange types and their routing semantics, we need to introduce message attributes. Every <span class="caps">AMQP</span> message has a number of <span class="note">attributes</span>. Some attributes are important and used very often, others are rarely used. <span class="caps">AMQP</span> message attributes are metadata and are similar in purpose to <span class="caps">HTTP</span> request and response headers.</p>
<p>Every <span class="caps">AMQP</span> v0.9.1 message has an attribute called <span class="note">routing key</span>. The routing key is an &#8220;address&#8221; that the exchange may use to decide how to route the message . This is similar to, but more generic than, a <span class="caps">URL</span> in <span class="caps">HTTP</span>. Most exchange types use the routing key to implement routing logic, but some ignore it and use other criteria (e.g. message content).</p>
<h2>Fanout exchanges</h2>
<h3>How fanout exchanges route messages</h3>
<p>A fanout exchange routes messages to all of the queues that are bound to it and the routing key is ignored. If N queues are bound to a fanout exchange, when a new message is published to that exchange a <strong>copy of the message</strong> is delivered to all N queues. Fanout exchanges are ideal for the <a href="http://en.wikipedia.org/wiki/Broadcasting_%28computing%29">broadcast routing</a> of messages.</p>
<p>Graphically this can be represented as:</p>
<p><img src="https://github.com/ruby-amqp/amqp/raw/master/docs/diagrams/004_fanout_exchange.png" alt="" /></p>
<h3>Declaring a fanout exchange</h3>
<p>There are two ways to declare a fanout exchange:</p>
<ul>
	<li>By instantiating an <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange"><span class="caps">AMQP</span>::Exchange</a> and specifying the type as &#8220;:fanout&#8221;</li>
	<li>By using the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#fanout-instance_method"><span class="caps">AMQP</span>::Channel#fanout</a>  method</li>
</ul>
<p>Here are two examples to demonstrate:</p>
<pre>exchange = AMQP::Exchange.new(channel, :fanout, "nodes.metadata")</pre>

<pre>exchange = channel.fanout("nodes.metadata")</pre>
<p>Both methods asynchronously declare a queue. Because the declaration necessitates a network round-trip, publishing operations on <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange"><span class="caps">AMQP</span>::Exchange</a> instances are delayed until the broker reply (`exchange.declare-ok`) is received.</p>
<p>Also, both methods let you pass a block to run a piece of code when the broker responds with an `exchange.declare-ok` (meaning that the exchange has been successfully declared).</p>
<pre>channel.fanout("nodes.metadata") do |exchange|
  # exchange is declared and ready to be used.
end</pre>
<h3>Fanout routing example</h3>
<p>To demonstrate fanout routing behavior we can declare 10 server-named exclusive queues, bind them all to one fanout exchange and then publish a message to the exchange:</p>
<pre>exchange = channel.topic("amqpgem.examples.routing.fanout_routing", :auto_delete =&gt; true)

10.times do
  q = channel.queue("", :exclusive =&gt; true, :auto_delete =&gt; true).bind(exchange)
  q.subscribe do |payload|
    puts "Queue #{q.name} received #{payload}"
  end
end</pre>

<pre># Publish some test data after all queues are declared and bound
EventMachine.add_timer(1.2) { exchange.publish "Hello, fanout exchanges world!" }</pre>
<p>When run, this example produces the following output:</p>
<p><code>Queue amq.gen-0p/BjxGNCue42RcJhpUrdg== received Hello, fanout exchanges world!
Queue amq.gen-3GXULvZuYh1KsOD83yvlNg== received Hello, fanout exchanges world!
Queue amq.gen-4EcyydTfoZzXjNSSLsh09Q== received Hello, fanout exchanges world!
Queue amq.gen-B1isyTpR5svB6ClQ2TQEBQ== received Hello, fanout exchanges world!
Queue amq.gen-FwLLioB7Mk4LGA4yJ1Mo7A== received Hello, fanout exchanges world!
Queue amq.gen-OtBQokiA/DmNkB5bPzaRig== received Hello, fanout exchanges world!
Queue amq.gen-RYHQUrj3yihb0DRF7KVpRg== received Hello, fanout exchanges world!
Queue amq.gen-SZJ40mGwbhdcbOGeHMhUkg== received Hello, fanout exchanges world!
Queue amq.gen-sDeVZg9Vx1knq+n9EMi8tA== received Hello, fanout exchanges world!
Queue amq.gen-uWOuVaosW4bWAHqKG6pZVw== received Hello, fanout exchanges world!</code></p>
<p>Each of the queues bound to the exchange receives a <strong>copy</strong> of the message.</p>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "bundler"
Bundler.setup

$:.unshift(File.expand_path("../../../lib", __FILE__))

require "amqp"

EventMachine.run do
  AMQP.connect("amqp://dev.rabbitmq.com") do |connection|
    channel  = AMQP::Channel.new(connection)
    exchange = channel.topic("amqpgem.examples.routing.fanout_routing", :auto_delete =&gt; true)

    # Subscribers.
    10.times do
      q = channel.queue("", :exclusive =&gt; true, :auto_delete =&gt; true).bind(exchange)
      q.subscribe do |payload|
        puts "Queue #{q.name} received #{payload}"
      end
    end

    # Publish some test data in a bit, after all queues are declared &amp; bound
    EventMachine.add_timer(1.2) { exchange.publish "Hello, fanout exchanges world!" }


    show_stopper = Proc.new { connection.close { EventMachine.stop } }

    Signal.trap "TERM", show_stopper
    EM.add_timer(3, show_stopper)
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1020181">gist</a>)</span></p>
<h3>Fanout use cases</h3>
<p>Because a fanout exchange delivers a copy of a message to every queue bound to it, its use cases are quite similar:</p>
<ul>
	<li>Massively multiplayer online (<span class="caps">MMO</span>) games can use it for leaderboard updates or other global events</li>
	<li>Sport news sites can use fanout exchanges for distributing score updates to mobile clients in near real-time</li>
	<li>Distributed systems can broadcast various state and configuration updates</li>
	<li>Group chats can distribute messages between participants using a fanout exchange (although <span class="caps">AMQP</span> does not have a built-in concept of presence, so <a href="http://xmpp.org"><span class="caps">XMPP</span></a> may be a better choice)</li>
</ul>
<h3>Pre-declared fanout exchanges</h3>
<p><span class="caps">AMQP</span> v0.9.1 brokers must implement a fanout exchange type and pre-declare one instance with the name of &#8220;amq.fanout&#8221;.</p>
<p>Applications can rely on that exchange always being available to them. Each vhost has a separate instance of that exchange, it is <strong>not shared across vhosts</strong> for obvious reasons.</p>
<h2>Direct exchanges</h2>
<h3>How direct exchanges route messages</h3>
<p>A direct exchange delivers messages to queues based on a <span class="note">message routing key</span>, an attribute that every <span class="caps">AMQP</span> v0.9.1 message contains.</p>
<p>Here is how it works:</p>
<ul>
	<li>A queue binds to the exchange with a routing key K</li>
	<li>When a new message with routing key R arrives at the direct exchange, the exchange routes it to the queue if K = R</li>
</ul>
<p>A direct exchange is ideal for the <a href="http://en.wikipedia.org/wiki/Unicast">unicast routing</a> of messages (although they can be used for <a href="http://en.wikipedia.org/wiki/Multicast">multicast routing</a> as well).</p>
<p>Here is a graphical representation:</p>
<p><img src="https://github.com/ruby-amqp/amqp/raw/master/docs/diagrams/005_direct_exchange.png" alt="" /></p>
<h3>Declaring a direct exchange</h3>
<p>There are two ways to declare a direct exchange:</p>
<ul>
	<li>By instantiating a <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange"><span class="caps">AMQP</span>::Exchange</a> and specifying its type as &#8220;:direct&#8221;</li>
	<li>By using the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#direct-instance_method"><span class="caps">AMQP</span>::Channel#direct</a> method</li>
</ul>
<p>Here are two examples to demonstrate:</p>
<pre>exchange = AMQP::Exchange.new(channel, :direct, "nodes.metadata")</pre>

<pre>exchange = channel.direct("nodes.metadata")</pre>
<p>Both methods asynchronously declare a queue. Because the declaration necessitates a network round trip, publishing operations on <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange"><span class="caps">AMQP</span>::Exchange</a> instances are delayed until a broker reply (`exchange.declare-ok`) is received.</p>
<p>Also, both methods let you pass a block to run a piece of code when the broker responds with `exchange.declare-ok` (meaning that the exchange has been successfully declared).</p>
<pre>channel.direct("pages.content.extraction") do |exchange|
  # exchange is declared and ready to be used.
end</pre>
<h3>Direct routing example</h3>
<p>Since direct exchanges use the <strong>message routing key</strong> for routing, message producers need to specify it:</p>
<pre>exchange.publish("Hello, direct exchanges world!", :routing_key =&gt; "amqpgem.examples.queues.shared")</pre>
<p>The routing key will then be compared for equality with routing keys on bindings, and consumers that subscribed with the same routing key each get a copy of the message:</p>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "bundler"
Bundler.setup

$:.unshift(File.expand_path("../../../lib", __FILE__))

require "amqp"

EventMachine.run do
  AMQP.connect do |connection|
    channel1  = AMQP::Channel.new(connection)
    channel2  = AMQP::Channel.new(connection)
    exchange = channel1.direct("amqpgem.examples.exchanges.direct", :auto_delete =&gt; true)

    q1 = channel1.queue("amqpgem.examples.queues.shared", :auto_delete =&gt; true).bind(exchange, :routing_key =&gt; "shared.key")
    q1.subscribe do |payload|
      puts "Queue #{q1.name} on channel 1 received #{payload}"
    end

    # since the queue is shared, binding here is redundant but we will leave it in for completeness.
    q2 = channel2.queue("amqpgem.examples.queues.shared", :auto_delete =&gt; true).bind(exchange, :routing_key =&gt; "shared.key")
    q2.subscribe do |payload|
      puts "Queue #{q2.name} on channel 2 received #{payload}"
    end

    # Publish some test data in a bit, after all queues are declared &amp; bound
    EventMachine.add_timer(1.2) do
      5.times { |i| exchange.publish("Hello #{i}, direct exchanges world!", :routing_key =&gt; "shared.key") }
    end

    show_stopper = Proc.new { connection.close { EventMachine.stop } }

    Signal.trap "TERM", show_stopper
    EM.add_timer(3, show_stopper)
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1041787">gist</a>)</span></p>
<h3>Direct exchanges and load balancing of messages</h3>
<p>Direct exchanges are often used to distribute tasks between multiple workers (instances of the same application) in a round robin manner. When doing so, it is important to understand that, in <span class="caps">AMQP</span> v0.9.1, <strong>messages are load balanced between consumers and not between queues</strong>.</p>
<p>The Ruby amqp gem historically has a limitation that only one consumer (message handler) is allowed per <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue"><span class="caps">AMQP</span>::Queue</a> instance, however, this limitation will be addressed in the future. With the amqp gem v0.8.x, if you want to load balance messages between multiple consumers in the same application/OS process, then you need to use a separate channel for each of the consumers.</p>
<p>The <a href="/articles/working_with_queues/">Working With Queues</a> and <a href="/articles/patterns_and_use_cases/">Patterns and Use Cases</a> guides provide more information on this subject.</p>
<h3>Pre-declared direct exchanges</h3>
<p><span class="caps">AMQP</span> v0.9.1 brokers must implement a direct exchange type and pre-declare two instances:</p>
<ul>
	<li><span class="note">amq.direct</span></li>
	<li><strong>&quot;&quot;</strong> exchange known as <span class="note">default exchange</span> (unnamed, referred to as an empty string by many clients including amqp Ruby gem)</li>
</ul>
<p>Applications can rely on those exchanges always being available to them. Each vhost has separate instances of those<br />
exchanges, they are <strong>not shared across vhosts</strong> for obvious reasons.</p>
<h3>Default exchange</h3>
<p>The default exchange is a direct exchange with no name (the amqp gem refers to it using an empty string) pre-declared by the broker. It has one special property that makes it very useful for simple applications, namely that <strong>every queue is automatically bound to it with a routing key which is the same as the queue name</strong>.</p>
<p>For example, when you declare a queue with the name of &#8220;search.indexing.online&#8221;, the <span class="caps">AMQP</span> broker will bind it to the default exchange using &#8220;search.indexing.online&#8221; as the routing key. Therefore a message published to the default exchange with routing key = &#8220;search.indexing.online&#8221; will be routed to the queue &#8220;search.indexing.online&#8221;. In other words, the default exchange makes it <strong>seem like it is possible to deliver messages directly to queues</strong>, even though that is not technically what is happening.</p>
<p>The amqp gem offers two ways of obtaining a reference to the default exchange:</p>
<ul>
	<li>Using the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#default_exchange-instance_method"><span class="caps">AMQP</span>::Channel#default_exchange</a> method</li>
	<li>Using the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#direct-instance_method"><span class="caps">AMQP</span>::Channel#direct</a> method with an empty string as the exchange name</li>
</ul>
<p><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#initialize-instance_method"><span class="caps">AMQP</span>::Exchange#initialize</a> can also be used, but requires more coding effort and it offers no benefits over instance methods on <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel"><span class="caps">AMQP</span>::Channel</a> in this particular case.</p>
<p>Some examples of usage:</p>
<pre>exchange = AMQP::Exchange.new(channel, :direct, "")</pre>

<pre>exchange = channel.default_exchange</pre>

<pre>exchange = channel.direct("")</pre>
<p>The default exchange is used by the &#8220;Hello, World&#8221; example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

EventMachine.run do
  AMQP.connect(:host =&gt; '127.0.0.1') do |connection|
    puts "Connected to AMQP broker. Running #{AMQP::VERSION} version of the gem..."

    channel  = AMQP::Channel.new(connection)

    channel.queue("amqpgem.examples.helloworld", :auto_delete =&gt; true).subscribe do |payload|
      puts "Received a message: #{payload}. Disconnecting..."

      connection.close { EventMachine.stop }
    end

    channel.direct("").publish "Hello, world!", :routing_key =&gt; "amqpgem.examples.helloworld"
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998691">gist</a>)</span></p>
<p>Additionally, the routing example above can be rewritten to use the default exchange:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

EventMachine.run do
  AMQP.connect do |connection|
    channel1  = AMQP::Channel.new(connection)
    channel2  = AMQP::Channel.new(connection)
    exchange = channel1.default_exchange

    q1 = channel1.queue("amqpgem.examples.queues.shared", :auto_delete =&gt; true)
    q1.subscribe do |payload|
      puts "Queue #{q1.name} on channel 1 received #{payload}"
    end

    q2 = channel2.queue("amqpgem.examples.queues.shared", :auto_delete =&gt; true)
    q2.subscribe do |payload|
      puts "Queue #{q2.name} on channel 2 received #{payload}"
    end

    # Publish some test data in a bit, after queues are declared &amp; bound
    EventMachine.add_timer(0.3) do
      5.times { |i| exchange.publish("Hello #{i}, fanout exchanges world!", :routing_key =&gt; "amqpgem.examples.queues.shared") }
    end


    show_stopper = Proc.new { connection.close { EventMachine.stop } }
    Signal.trap "TERM", show_stopper
    EM.add_timer(3, show_stopper)
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1041778">gist</a>)</span></p>
<h3>Direct exchange use cases</h3>
<p>Direct exchanges can be used in a wide variety of cases:</p>
<ul>
	<li>Direct (near real-time) messages to individual players in an <span class="caps">MMO</span> game</li>
	<li>Delivering notifications to specific geographic locations (for example, points of sale)</li>
	<li>Distributing tasks between multiple instances of the same application all having the same function, for example, image processors</li>
	<li>Passing data between workflow steps, each having an identifier (also consider using headers exchange)</li>
	<li>Delivering notifications to individual software services in the network</li>
</ul>
<h2>Topic exchanges</h2>
<h3>How topic exchanges route messages</h3>
<p>Topic exchanges route messages to one or many queues based on matching between a message routing key and the pattern that was used to bind a queue to an exchange. The topic exchange type is often used to implement various <a href="http://en.wikipedia.org/wiki/Publish/subscribe">publish/subscribe pattern</a> variations.</p>
<p>Topic exchanges are commonly used for the <a href="http://en.wikipedia.org/wiki/Multicast">multicast routing</a> of messages.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/30/Multicast.svg/500px-Multicast.svg.png" alt="" /></p>
<p>Topic exchanges can be used for <a href="http://en.wikipedia.org/wiki/Broadcasting_%28computing%29">broadcast routing</a>, but fanout exchanges are usually more efficient for this use case.</p>
<h3>Topic exchange routing example</h3>
<p>Two classic examples of topic-based routing are stock price updates and location-specific data (for instance, weather broadcasts). Consumers indicate which topics they are interested in (think of it like subscribing to a feed for an individual tag of your favourite blog as opposed to the full feed). The routing is enabled by specifying a routing pattern_ to the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#bind-instance_method"><span class="caps">AMQP</span>::Queue#bind</a> method, for example:</p>
<pre>channel.queue("americas.south").bind(exchange, :routing_key =&gt; "americas.south.#").subscribe do |headers, payload|
  puts "An update for South America: #{payload}, routing key is #{headers.routing_key}"
end</pre>
<p>In the example above we bind a queue with the name of &#8220;americas.south&#8221; to the topic exchange declared earlier using the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#bind-instance_method"><span class="caps">AMQP</span>::Queue#bind</a> method. This means that only messages with a routing key matching &#8220;americas.south.#&#8221; will be routed to the &#8220;americas.south&#8221; queue.</p>
<p>A routing pattern consists of several words separated by dots, in a similar way to <span class="caps">URI</span> path segments being joined by slash. A few of examples:</p>
<ul>
	<li>asia.southeast.thailand.bangkok</li>
	<li>sports.basketball</li>
	<li>usa.nasdaq.aapl</li>
	<li>tasks.search.indexing.accounts</li>
</ul>
<p>The following routing keys match the &#8220;americas.south.#&#8221; pattern:</p>
<ul>
	<li>americas.south</li>
	<li>americas.south.<strong>brazil</strong></li>
	<li>americas.south.<strong>brazil.saopaolo</strong></li>
	<li>americas.south.<strong>chile.santiago</strong></li>
</ul>
<p>In other words, the &#8220;#&#8221; part of the pattern matches 0 or more words.</p>
<p>For the pattern &#8220;americas.south.*&#8221;, some matching routing keys are:</p>
<ul>
	<li>americas.south.<strong>brazil</strong></li>
	<li>americas.south.<strong>chile</strong></li>
	<li>americas.south.<strong>peru</strong></li>
</ul>
<p>but not</p>
<ul>
	<li>americas.south</li>
	<li>americas.south.chile.santiago</li>
</ul>
<p>As you can see, the &#8220;*&#8221; part of the pattern matches 1 word only.</p>
<p>Full example:</p>
<pre># -*- coding: ascii-8bit -*-
require "rubygems" # or use Bundler.setup
require "amqp"

EventMachine.run do
  AMQP.connect do |connection|
    channel  = AMQP::Channel.new(connection)
    exchange = channel.topic("pub/sub", :auto_delete =&gt; true)

    # Subscribers
    channel.queue("", :exclusive =&gt; true) do |queue|
      queue.bind(exchange, :routing_key =&gt; "americas.north.#").subscribe do |metadata, payload|
        puts "An update for North America: #{payload}, routing key is #{metadata.routing_key}"
      end
    end
    channel.queue("americas.south").bind(exchange, :routing_key =&gt; "americas.south.#").subscribe do |metadata, payload|
      puts "An update for South America: #{payload}, routing key is #{metadata.routing_key}"
    end
    channel.queue("us.california").bind(exchange, :routing_key =&gt; "americas.north.us.ca.*").subscribe do |metadata, payload|
      puts "An update for US/California: #{payload}, routing key is #{metadata.routing_key}"
    end
    channel.queue("us.tx.austin").bind(exchange, :routing_key =&gt; "#.tx.austin").subscribe do |metadata, payload|
      puts "An update for Austin, TX: #{payload}, routing key is #{metadata.routing_key}"
    end
    channel.queue("it.rome").bind(exchange, :routing_key =&gt; "europe.italy.rome").subscribe do |metadata, payload|
      puts "An update for Rome, Italy: #{payload}, routing key is #{metadata.routing_key}"
    end
    channel.queue("asia.hk").bind(exchange, :routing_key =&gt; "asia.southeast.hk.#").subscribe do |metadata, payload|
      puts "An update for Hong Kong: #{payload}, routing key is #{metadata.routing_key}"
    end

    # publish updates 1 second later, after all queues are declared and bound
    EventMachine.add_timer(1) do
      exchange.publish("San Diego update", :routing_key =&gt; "americas.north.us.ca.sandiego").
        publish("Berkeley update",        :routing_key =&gt; "americas.north.us.ca.berkeley").
        publish("San Francisco update",    :routing_key =&gt; "americas.north.us.ca.sanfrancisco").
        publish("New York update",         :routing_key =&gt; "americas.north.us.ny.newyork").
        publish("SÃ£o Paolo update",        :routing_key =&gt; "americas.south.brazil.saopaolo").
        publish("Hong Kong update",        :routing_key =&gt; "asia.southeast.hk.hongkong").
        publish("Kyoto update",            :routing_key =&gt; "asia.southeast.japan.kyoto").
        publish("Shanghai update",         :routing_key =&gt; "asia.southeast.prc.shanghai").
        publish("Rome update",             :routing_key =&gt; "europe.italy.roma").
        publish("Paris update",            :routing_key =&gt; "europe.france.paris")
    end

    show_stopper = Proc.new { connection.close { EventMachine.stop } }

    Signal.trap "TERM", show_stopper
    EM.add_timer(3, show_stopper)
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1020308">gist</a>)</span></p>
<h3>Topic exchange use cases</h3>
<p>Topic exchanges have a very broad set of use cases. Whenever a problem involves multiple consumers/applications that selectively choose which type of messages they want to receive, the use of topic exchanges should be considered. To name a few examples:</p>
<ul>
	<li>Distributing data relevant to specific geographic location, for example, points of sale</li>
	<li>Background task processing done by multiple workers, each capable of handling specific set of tasks</li>
	<li>Stocks price updates (and updates on other kinds of financial data)</li>
	<li>News updates that involve categorization or tagging (for example, only for a particular sport or team)</li>
	<li>Orchestration of services of different kinds in the cloud</li>
	<li>Distributed architecture/OS-specific software builds or packaging where each builder can handle only one architecture or OS</li>
</ul>
<h2>Declaring/Instantiating exchanges</h2>
<p>With the Ruby amqp gem, exchanges can be declared in two ways:</p>
<ul>
	<li>By using the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#initialize-instance_method"><span class="caps">AMQP</span>::Exchange#initialize</a> method that takes an optional callback</li>
	<li>By using a number of convenience methods on <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel"><span class="caps">AMQP</span>::Channel</a> instances:</li>
</ul>

	<ul>
		<li><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#direct-instance_method"><span class="caps">AMQP</span>::Channel#direct</a></li>
		<li><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#default_exchange-instance_method"><span class="caps">AMQP</span>::Channel#default_exchange</a></li>
		<li><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#topic-instance_method"><span class="caps">AMQP</span>::Channel#topic</a></li>
		<li><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#fanout-instance_method"><span class="caps">AMQP</span>::Channel#fanout</a></li>
		<li><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#headers-instance_method"><span class="caps">AMQP</span>::Channel#headers</a></li>
	</ul><p>The previous sections on specific exchange types (direct, fanout, headers, etc.) provide plenty of examples of how these methods can be used.</p>
<h2>Publishing messages</h2>
<p>To publish a message to an <span class="caps">AMQP</span> exchange, use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a>:</p>
<pre>exchange.publish("Some payload")</pre>
<p><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a> can accept any object that responds to the `to_s` method, not just string instances:</p>
<pre>class Message

  #
  # API
  #

  # ...

  def to_s
    # returns textual or binary representation of the message as a String instance
  end

  # ...
end

exchange.publish(Message.new)
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1020336">gist</a>)</span></p>
<p>The message payload is completely opaque to the library and is not modified in any way.</p>
<h3>Data serialization</h3>
<p>You are encouraged to take care of data serialization before publishing (i.e. by using <span class="caps">JSON</span>, Thrift, Protocol Buffers or some other serialization library). Note that because <span class="caps">AMQP</span> is a binary protocol, text formats like <span class="caps">JSON</span> largely lose their advantage of being easy to inspect as data travels across the network, so consider using <a href="http://bsonspec.org"><span class="caps">BSON</span></a> instead.</p>
<p>A few popular options for data serialization are:</p>
<ul>
	<li><span class="caps">JSON</span>: <a href="https://rubygems.org/gems/json">json gem</a> (part of standard Ruby library on Ruby 1.9) or <a href="https://rubygems.org/gems/yajl-ruby">yajl-ruby</a> (Ruby bindings to <span class="caps">YAJL</span>)</li>
	<li><span class="caps">BSON</span>: <a href="https://rubygems.org/gems/bson">bson gem</a> for JRuby (implemented as a Java extension) and <a href="https://rubygems.org/bson_ext">bson_ext</a> (C extension) for C-based Rubies</li>
	<li><a href="http://msgpack.org">Message Pack</a> has Ruby bindings but currently does not provide Java implementation for JRuby</li>
	<li><span class="caps">XML</span>: <a href="https://nokogiri.org">Nokogiri</a> is a swiss army knife for <span class="caps">XML</span> processing with Ruby, built on top of libxml2</li>
	<li>Protocol Buffers: <a href="https://github.com/bmizerany/beefcake">beefcake</a></li>
	<li>Thrift: <a href="https://github.com/fauna/thrift_client">thrift-client</a></li>
</ul>
<h3>Message metadata</h3>
<p><span class="caps">AMQP</span> messages have various metadata attributes that can be set when a message is published. Some of the attributes are well-known and mentioned in the <span class="caps">AMQP</span> v0.9.1 specification, others are specific to a particular application. Well-known attributes are listed here as options that <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a> takes:</p>
<ul>
	<li>:routing_key</li>
	<li>:persistent</li>
	<li>:immediate</li>
	<li>:mandatory</li>
	<li>:content_type</li>
	<li>:content_encoding</li>
	<li>:priority</li>
	<li>:message_id</li>
	<li>:correlation_id</li>
	<li>:reply_to</li>
	<li>:type</li>
	<li>:user_id</li>
	<li>:app_id</li>
	<li>:timestamp</li>
	<li>:expiration</li>
</ul>
<p>All other attributes can be added to a <em>headers table</em> (in Ruby parlance, headers hash) that <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a> accepts as the &#8220;:headers&#8221; argument.</p>
<p>An example to show how message metadata attributes are passed to <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a>:</p>
<pre>exchange.publish("Hey, what a great view!",
                 :app_id         =&gt; "amqpgem.example",
                 :priority       =&gt; 8,
                 :type           =&gt; "kinda.checkin",
                 :correlation_id =&gt; "b907b65a4876fc0d4b12fbdef1b41fb0a9876a94",
                 # headers table keys can be anything
                 :headers        =&gt; {
                   :coordinates =&gt; {
                     :latitude  =&gt; 59.35,
                     :longitude =&gt; 18.066667
                   },
                   :participants =&gt; 11,
                   :venue        =&gt; "Stockholm"
                 },
                 :timestamp   =&gt; Time.now.to_i,
                 :routing_key =&gt; "amqpgem.key")
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1020424">gist</a>)</span></p>
<dl>
  <dt>:routing_key</dt>
  <dd>Used for routing messages depending on the exchange type and configuration.</dd>
  <dt>:persistent</dt>
  <dd>When set to true, <span class="caps">AMQP</span> broker will persist message to disk.</dd>
  <dt>:immediate</dt>
<dd>
This flag tells the server how to react if the message cannot be routed to a queue consumer immediately. If this flag is set to true, the server will return
an undeliverable message to the producer with a basic.return <span class="caps">AMQP</span> method. If this flag is set to false, the server will queue the message, but with no guarantee
that it will ever be consumed.
</dd>
  <dt>:mandatory</dt>
<dd>
This flag tells the server how to react if the message cannot be routed to a queue. If this flag is set to true, the server will return an unroutable message
to the producer with a basic.return <span class="caps">AMQP</span> method. If this flag is set to false, the server silently drops the message.
</dd>
  <dt>:content_type</dt>
  <dd><span class="caps">MIME</span> content type of message payload. Has the same purpose/semantics as <span class="caps">HTTP</span> Content-Type header.</dd>
  <dt>:content_encoding</dt>
  <dd><span class="caps">MIME</span> content encoding of message payload. Has the same purpose/semantics as <span class="caps">HTTP</span> Content-Encoding header.</dd>
  <dt>:priority</dt>
  <dd>Message priority, from 0 to 9.</dd>
  <dt>:message_id</dt>
<dd>
Message identifier as a string. If applications need to identify messages, it is recommended that they use this attribute instead of putting it
into the message payload.
</dd>
  <dt>:reply_to</dt>
<dd>
Commonly used to name a reply queue (or any other identifier that helps a consumer application to direct its response).
Applications are encouraged to use this attribute instead of putting this information into the message payload.
</dd>
  <dt>:correlation_id</dt>
<dd>
ID of the message that this message is a reply to. Applications are encouraged to use this attribute instead of putting this information
into the message payload.
</dd>
  <dt>:type</dt>
  <dd>Message type as a string. Recommended to be used by applications instead of including this information into the message payload.</dd>
  <dt>:user_id</dt>
<dd>
Sender&#8217;s identifier. Note that RabbitMQ will check that the <a href="http://www.rabbitmq.com/extensions.html#validated-user-id">value of this attribute is the same as username <span class="caps">AMQP</span> connection was authenticated with</a>, it <span class="caps">SHOULD</span> <span class="caps">NOT</span> be used to transfer, for example, other application user ids or be used as a basis for some kind of Single Sign-On solution.
</dd>
  <dt>:app_id</dt>
  <dd>Application identifier string, for example, &#8220;eventoverse&#8221; or &#8220;webcrawler&#8221;</dd>
  <dt>:timestamp</dt>
  <dd>Timestamp of the moment when message was sent, in seconds since the Epoch</dd>
  <dt>:expiration</dt>
  <dd>Message expiration specification as a string</dd>
  <dt>:headers</dt>
  <dd>Ruby hash of any additional attributes that the application needs. Nested hashes are supported.</dd>
</dl>
<p>It is recommended that application authors use well-known message attributes when applicable instead of relying on custom headers or placing information into the message body. For example, if your application messages have priority, publishing timestamp, type and content type, you should use the respective <span class="caps">AMQP</span> message attributes instead of reinventing the wheel.</p>
<h3>Validated user_id</h3>
<p>In some scenarios it is useful for consumers to be able to know the identity of the user who published a message. RabbitMQ implements a feature known as <a href="http://www.rabbitmq.com/extensions.html#validated-user-id">validated User ID</a>. If this property is set by a publisher, its value must be the same as the name of the user used to open the connection. If the user-id property is not set, the publisher&#8217;s identity is not validated and remains private.</p>
<h3>Publishing callback and reliable delivery in distributed environments</h3>
<p>Sometimes it is convenient to execute an operation after publishing a message. For this, <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a> provides an optional callback. It is important to clear up some expectations of when exactly it is run and how it is related to topics of message  delivery reliability and so on.</p>
<pre>exchange.publish(payload, :persistent =&gt; true, :type =&gt; "reports.done") do
  # ...
end</pre>
<p>A common expectation of the code above is that it is run after the message &#8220;has been sent&#8221;, or even &#8220;has been delivered&#8221;. Unfortunately, neither of these expectations can be met by the Ruby amqp gem alone. Message publishing happens in several steps:</p>
<ul>
	<li><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a> takes a message and various metadata attributes</li>
	<li><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a> internally calls #to_s on the message argument to get message payload</li>
	<li>Resulting payload is staged for writing</li>
	<li>On the next event loop tick, data is transferred to the OS kernel using one of the underlying system calls (<a href="http://en.wikipedia.org/wiki/Epoll">epoll</a>, <a href="http://en.wikipedia.org/wiki/Kqueue">kqueue</a> and so on) or <span class="caps">NIO</span> channels (in the case of JRuby)</li>
	<li>OS kernel buffers data before sending it</li>
	<li>Network driver may also employ buffering</li>
</ul>
<p><span class="help-block"><br />
As you can see, &#8220;when data is sent&#8221; is a complicated issue and while methods to flush buffers certainly exist on various platforms, doing so in a cross-platform way that <strong>includes the <span class="caps">JVM</span></strong> (that EventMachine also runs on) is non-trivial. In addition, even flushing buffers does not guarantee that the data was received by the broker because it might have crashed while data was travelling down the wire. The only way to reliably know whether data was received by the broker or a peer application is to use message acknowledgements. This is how <span class="caps">TCP</span> works and this approach is proven to work at  enormous scale of the modern Internet. <span class="caps">AMQP</span> (the protocol) fully embraces this fact and the amqp gem follows.<br />
</span></p>
<p>Given all of this, you may ask &#8220;when does the &#8221;highlight&quot; href=&#8220;http://rubydoc.info/github/ruby-amqp/amqp/master/<span class="caps">AMQP</span>/Exchange#publish-instance_method&#8221;&gt;AMQP::Exchange#publish</a> callback fire?&quot; The answer is on the next event loop tick. By then the data is pushed down to the OS kernel. As far as the Ruby library is concerned, it is reasonably safe behavior.</p>
<p><span class="help-block"><br />
The <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a> callback is fired on the next event loop tick. Data is staged for delivery immediately. Applications <span class="caps">MUST</span> <span class="caps">NOT</span> assume that by the time the callback has fired, the data is guaranteed to leave the local machine networking stack, reach the <span class="caps">AMQP</span> broker or any peer applications that the message needs to be routed to.<br />
</span></p>
<p>In cases when you cannot afford to lose a single message, <span class="caps">AMQP</span> v0.9.1 applications can use one (or a combination of) the following protocol features:</p>
<ul>
	<li>Publisher confirms (a RabbitMQ-specific extension to <span class="caps">AMQP</span> v0.9.1)</li>
	<li>Publishing messages as immediate and/or mandatory</li>
	<li>Transactions (these introduce noticeable overhead and have a relatively narrow set of use cases)</li>
</ul>
<p>A more detailed overview of the pros and cons of each option can be found in a <a href="http://bit.ly/rabbitmq-publisher-confirms">blog post that introduces Publisher Confirms extension</a> by the RabbitMQ team. The next sections of this guide will describe how the features above can be used with the Ruby amqp gem.</p>
<h3>Publishing messages as immediate</h3>
<p>When publishing messages, it is possible to use the &#8220;:immediate&#8221; option to publish a message as &#8220;immediate&#8221;. When an immediate message cannot be delivered to any consumer (meaning that one or more queues to which the message was routed have no active consumers), then the message is returned to the producer.</p>
<p>An example of <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a> being used to publish an immediate message:</p>
<pre>exchange.publish("Message ##{i}", :immediate =&gt; true)</pre>
<p>The following code example demonstrates a message that is published as immediate but cannot be immediately consumed (no consumers) and thus is returned back to the producer:</p>
<pre>require 'rubygems'
require 'amqp'

puts "=&gt; Handling returned messages"
puts

AMQP.start(:host =&gt; '127.0.0.1') do |connection|
  channel  = AMQP.channel
  channel.on_error { |ch, channel_close| EventMachine.stop; raise "channel error: #{channel_close.reply_text}" }

  exchange = channel.fanout("amq.fanout")
  exchange.on_return do |basic_return, metadata, payload|
    puts "#{payload} was returned! reply_code = #{basic_return.reply_code}, reply_text = #{basic_return.reply_text}"
  end

  EventMachine.add_timer(0.3) {
    10.times do |i|
      exchange.publish("Message ##{i}", :immediate =&gt; true)
    end
  }

  EventMachine.add_timer(2) {
    connection.close { EventMachine.stop }
  }
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1025700">gist</a>)</span></p>
<h3>Publishing messages as mandatory</h3>
<p>When publishing messages, it is possible to use the &#8220;:mandatory&#8221; option to publish a message as &#8220;mandatory&#8221;. When a mandatory message cannot be <strong>routed</strong> to any queue (for example, there are no bindings or none of the bindings match), the message is returned to the producer.</p>
<p>The following code example demonstrates a message that is published as mandatory but cannot be routed (no bindings) and thus is returned back to the producer:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require 'amqp'

puts "=&gt; Handling a returned unroutable message that was published as mandatory"
puts

AMQP.start(:host =&gt; '127.0.0.1') do |connection|
  channel  = AMQP.channel
  channel.on_error { |ch, channel_close| EventMachine.stop; raise "channel error: #{channel_close.reply_text}" }

  # this exchange has no bindings, so messages published to it cannot be routed.
  exchange = channel.fanout("amqpgem.examples.fanout", :auto_delete =&gt; true)
  exchange.on_return do |basic_return, metadata, payload|
    puts "#{payload} was returned! reply_code = #{basic_return.reply_code}, reply_text = #{basic_return.reply_text}"
  end

  EventMachine.add_timer(0.3) {
    10.times do |i|
      exchange.publish("Message ##{i}", :mandatory =&gt; true)
    end
  }

  EventMachine.add_timer(2) { connection.close { EventMachine.stop } }
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1041835">gist</a>)</span></p>
<h3>Returned messages</h3>
<p>When a message is returned, the application that produced it can handle that message in different ways:</p>
<ul>
	<li>Store it for later redelivery in a persistent store</li>
	<li>Publish it to a different destination</li>
	<li>Log the event and discard the message</li>
</ul>
<p>Returned messages contain information about the exchange they were published to. For convenience, the amqp gem associates returned message callbacks with <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange"><span class="caps">AMQP</span>::Exchange</a> instances. To handle returned messages, use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#on_return-instance_method"><span class="caps">AMQP</span>::Exchange#on_return</a>:</p>
<pre>exchange.on_return do |basic_return, metadata, payload|
  puts "#{payload} was returned! reply_code = #{basic_return.reply_code}, reply_text = #{basic_return.reply_text}"
end</pre>
<p>A returned message handler has access to <span class="caps">AMQP</span> method (basic.return) information, message metadata and payload. The metadata and message body are returned without modifications so that the application can store the message for later redelivery.</p>
<h3>Publishing persistent messages</h3>
<p>Messages potentially spend some time in the queues to which they were routed before they are consumed. During this period of time, the broker may crash or experience a restart. To survive it, messages must be persisted to disk. This has a negative effect on performance, especially with network attached storage like <span class="caps">NAS</span> devices and Amazon <span class="caps">EBS</span>. <span class="caps">AMQP</span> v0.9.1 lets applications trade off performance for durability, or vice versa, on a message-by-message basis.</p>
<p>To publish a persistent message, use the &#8220;:persistent&#8221; option that <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a> accepts:</p>
<pre>exchange.publish(payload, :persistent =&gt; true)</pre>
<p><span class="help-block"><br />
Note that in order to survive a broker crash, both the message and the queue that it was routed to must be persistent/durable.<br />
</span></p>
<p><a href="/articles/durability/">Durability and Message Persistence</a> provides more information on the subject.</p>
<h3>Publishing In Multi-threaded Environments</h3>
<p>When using amqp gem in multi-threaded environments, the rule of thumb is: avoid sharing <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel"><span class="caps">AMQP</span>::Channel</a> instances across threads.</p>
<p>Starting with 0.8.0.RC14, <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a> synchronizes data delivery on the channel object associated with exchange. This protects application developers from the most common problems related to publishing messages on a shared channel from multiple threads, however, by no means protects from every possible concurrency hazard.</p>
<p><span class="help-block"><br />
When using amqp gem in multi-threaded environments, the rule of thumb is: avoid sharing <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel"><span class="caps">AMQP</span>::Channel</a> instances across threads.<br />
</span></p>
<h3>Sending one-off messages</h3>
<p>The following example publishes a message and <strong>safely</strong> closes the <span class="caps">AMQP</span> connection afterwards by passing a block to <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#publish-instance_method"><span class="caps">AMQP</span>::Exchange#publish</a> :</p>
<pre>require 'rubygems' # or use Bundler.setup
require 'amqp'

puts "=&gt; Publishing and immediately stopping the event loop in the callback"
puts

EventMachine.run do
  connection = AMQP.connect(:host =&gt; '127.0.0.1')
  channel    = AMQP::Channel.new(connection)

  # topic exchange is used just as example. Often it is more convenient to use default exchange,
  # see http://bit.ly/amqp-gem-default-exchange
  exchange = channel.topic("a.topic", :durable =&gt; true, :auto_delete =&gt; true)
  queue    = channel.queue("a.queue", :auto_delete =&gt; true).bind(exchange, :routing_key =&gt; "events.#")

  exchange.publish('hello world', :routing_key =&gt; "events.hits.homepage", :persistent =&gt; true, :nowait =&gt; false) do
    puts "About to unsubscribe..."
    connection.close { EventMachine.stop }
  end

end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1020425">gist</a>)</span></p>
<h2>Headers exchanges</h2>
<p>Now that message attributes and publishing have been introduced, it is time to take a look at one more core exchange type in <span class="caps">AMQP</span> v0.9.1. It is called <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/headers">headers</a> exchange type and is quite powerful.</p>
<h3>How headers exchanges route messages</h3>
<h4>An example problem definition</h4>
<p>The best way to explain headers-based routing is with an example. Imagine a distributed <a href="http://martinfowler.com/articles/continuousIntegration.html">continuous integration</a> system that distributes builds across multiple machines with different hardware architectures (x86, IA-64, AMD64, <span class="caps">ARM</span> family and so on) and operating systems. It strives to provide a way for a community to contribute machines to run tests on and a nice build matrix like <a href="http://build.webkit.org/waterfall?category=core">the one WebKit uses</a>. One key problem such systems face is build distribution. It would be nice if a messaging broker could figure out which machine has which OS, architecture or combination of the two and route build request messages accordingly.</p>
<p>A headers exchange is designed to help in situations like this by routing on multiple attributes that are more easily expressed as message metadata attributes (headers) rather than a routing key string.</p>
<h4>Routing on multiple message attributes</h4>
<p>Headers exchanges route messages based on message header matching. Headers exchanges ignore the routing key attribute. Instead, the attributes used for routing are taken from the &#8220;headers&#8221; attribute. When a queue is bound to a headers exchange, the &#8220;:arguments&#8221; attribute is used to define matching rules:</p>
<pre># when binding to a headers exchange, :arguments parameter is used to specify matching rules
@channel.queue("", :auto_delete =&gt; true).bind(exchange, :arguments =&gt; { :os =&gt; 'linux' })</pre>
<p>When matching on one header, a message is considered matching if the value of the header equals the value specified upon binding. Using the example above,<br />
some messages that match would be:</p>
<pre>exchange.publish "For linux/IA64",   :headers =&gt; { :arch =&gt; "IA64", :os =&gt; 'linux' }
exchange.publish "For linux/x86",    :headers =&gt; { :arch =&gt; "x86",  :os =&gt; 'linux' }
exchange.publish "For any linux",    :headers =&gt; { :os =&gt; 'linux' }</pre>
<p>The following example demonstrates matching on integer values:</p>
<pre># consumer part
@channel.queue("", :auto_delete =&gt; true).bind(exchange, :arguments =&gt; { :cores =&gt; 8 })

# ...

# producer part
exchange.publish "For ocotocore", :headers =&gt; { :cores =&gt; 8 }</pre>
<p>Matching on hashes (in <span class="caps">AMQP</span> v0.9.1 parlance &#8211; <em>attribute tables</em>) is also supported:</p>
<pre># consumer part
channel.queue("", :auto_delete =&gt; true).bind(exchange, :arguments =&gt; { :package =&gt; { :name =&gt; 'riak', :version =&gt; '0.14.2' } })

# ...

# producer part
exchange.publish "For nodes with Riak 0.14.2", :headers =&gt; { :package =&gt; { :name =&gt; 'riak', :version =&gt; '0.14.2' } }</pre>
<h4>Matching all vs matching one</h4>
<p>It is possible to bind a queue to a headers exchange using more than one header for matching. In this case, the broker needs one more piece of information from the application developer, namely, should it consider messages with any of the headers matching, or all of them? This is what the &#8220;x-match&#8221; binding argument is for:</p>
<pre>channel.queue("", :auto_delete =&gt; true).bind(exchange, :arguments =&gt; { 'x-match' =&gt; 'all', :arch =&gt; "ia64", :os =&gt; 'linux' })</pre>
<p>In the example above, only messages that have an &#8220;arch&#8221; header value equal to &#8220;ia64&#8221; and an &#8220;os&#8221; header value equal to &#8220;linux&#8221; will be considered matching.</p>
<pre>channel.queue("", :auto_delete =&gt; true).bind(exchange, :arguments =&gt; { 'x-match' =&gt; 'any', :os =&gt; 'macosx', :cores =&gt; 8 })</pre>
<p>When the &#8220;x-match&#8221; argument is set to &#8220;any&#8221;, just one matching header value is sufficient. So in the example above, any message with a &#8220;cores&#8221; header value equal to 8 will be considered matching.</p>
<h4>More examples</h4>
<p><span class="caps">TBD</span></p>
<h3>Declaring a headers exchange</h3>
<p>There are two ways to declare a headers exchange:</p>
<ul>
	<li>By instantiating <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange"><span class="caps">AMQP</span>::Exchange</a> and specifying type as &#8220;:headers&#8221;</li>
	<li>By using the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#headers-instance_method"><span class="caps">AMQP</span>::Channel#headers</a> method</li>
</ul>
<p>Here are two examples to demonstrate:</p>
<pre>exchange = AMQP::Exchange.new(channel, :headers, "builds")</pre>

<pre>exchange = channel.headers("builds")</pre>
<p>Both methods asynchronously declare a queue. Because declaration necessitates a network round trip, publishing operations on <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange"><span class="caps">AMQP</span>::Exchange</a> instances are delayed until the broker reply (`exchange.declare-ok`) is received.</p>
<p>Both methods let you pass a block to run a piece of code when the broker responds with `exchange.declare-ok` (meaning that the exchange has been successfully declared).</p>
<pre>channel.headers("builds") do |exchange|
  # exchange is declared and ready to be used.
end</pre>
<h3>Headers exchange routing example</h3>
<p>When there is just one queue bound to a headers exchange, messages are routed to it if one or all headers of the message match those specified upon binding. Whether it is &#8220;any header&#8221; or &#8220;all of them&#8221; depends on the &#8220;x-match&#8221; header value. In the case of multiple queues, a headers exchange will deliver a copy of a message to each queue, just like direct exchanges do. Distribution rules between consumers on a particular queue are the same as for a direct exchange.</p>
<p>Full example:</p>
<pre>require 'rubygems'
require 'amqp'

puts "=&gt; Headers routing example"
puts
AMQP.start do |connection|
  channel   = AMQP::Channel.new(connection)
  channel.on_error do |ch, channel_close|
    puts "A channel-level exception: #{channel_close.inspect}"
  end

  exchange = channel.headers("amq.match", :durable =&gt; true)

  channel.queue("", :auto_delete =&gt; true).bind(exchange, :arguments =&gt; { 'x-match' =&gt; 'all', :arch =&gt; "ia64", :os =&gt; 'linux' }).subscribe do |metadata, payload|
    puts "[linux/ia64] Got a message: #{payload}"
  end
  channel.queue("", :auto_delete =&gt; true).bind(exchange, :arguments =&gt; { 'x-match' =&gt; 'all', :arch =&gt; "x86", :os =&gt; 'linux' }).subscribe do |metadata, payload|
    puts "[linux/x86] Got a message: #{payload}"
  end
  channel.queue("", :auto_delete =&gt; true).bind(exchange, :arguments =&gt; { :os =&gt; 'linux'}).subscribe do |metadata, payload|
    puts "[linux] Got a message: #{payload}"
  end
  channel.queue("", :auto_delete =&gt; true).bind(exchange, :arguments =&gt; { 'x-match' =&gt; 'any', :os =&gt; 'macosx', :cores =&gt; 8 }).subscribe do |metadata, payload|
    puts "[macosx|octocore] Got a message: #{payload}"
  end
  channel.queue("", :auto_delete =&gt; true).bind(exchange, :arguments =&gt; { :package =&gt; { :name =&gt; 'riak', :version =&gt; '0.14.2' } }).subscribe do |metadata, payload|
    puts "[riak/0.14.2] Got a message: #{payload}"
  end

  EventMachine.add_timer(0.5) do
    exchange.publish "For linux/ia64",   :headers =&gt; { :arch =&gt; "ia64", :os =&gt; 'linux' }
    exchange.publish "For linux/x86",    :headers =&gt; { :arch =&gt; "x86", :os =&gt; 'linux'  }
    exchange.publish "For linux",        :headers =&gt; { :os =&gt; 'linux'  }
    exchange.publish "For OS X",         :headers =&gt; { :os =&gt; 'macosx' }
    exchange.publish "For solaris/ia64", :headers =&gt; { :os =&gt; 'solaris', :arch =&gt; 'ia64' }
    exchange.publish "For ocotocore",    :headers =&gt; { :cores =&gt; 8  }

    exchange.publish "For nodes with Riak 0.14.2", :headers =&gt; { :package =&gt; { :name =&gt; 'riak', :version =&gt; '0.14.2' } }
  end


  show_stopper = Proc.new do
    $stdout.puts "Stopping..."
    connection.close { EventMachine.stop }
  end

  Signal.trap "INT", show_stopper
  EventMachine.add_timer(2, show_stopper)
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1034875">gist</a>)</span></p>
<h3>Headers exchange use cases</h3>
<p>Headers exchanges can be looked upon as &#8220;direct exchanges on steroids&#8221;. Because they route based on header values, they can be used as direct exchanges where the routing key does not have to be a string; it could be an integer or a hash (dictionary) for example.</p>
<p>Some specific use cases:</p>
<ul>
	<li>Transfer of work between stages in a multi-step workflow (<a href="http://eaipatterns.com/RoutingTable.html">routing slip pattern</a>)</li>
	<li>Distributed build/continuous integration systems can distribute builds based on multiple parameters (OS, <span class="caps">CPU</span> architecture, availability of a particular package).</li>
</ul>
<h3>Pre-declared headers exchanges</h3>
<p><span class="caps">AMQP</span> v0.9.1 brokers should (as defined by <a href="http://www.ietf.org/rfc/rfc2119.txt"><span class="caps">IETF</span> <span class="caps">RFC</span> 2119</a>) implement a headers exchange type and pre-declare one instance with the name of &#8220;amq.match&#8221;. RabbitMQ also pre-declares one instance with the name of &#8220;amq.headers&#8221;. Applications can rely on that exchange always being available to them. Each vhost has a separate instance of those exchanges and they are <strong>not shared across vhosts</strong> for obvious reasons.</p>
<h2>Custom exchange types</h2>
<h3>x-random</h3>
<p>The <a href="https://github.com/jbrisbin/random-exchange">x-random <span class="caps">AMQP</span> exchange type</a> is a custom exchange type developed as a RabbitMQ plugin by Jon Brisbin. To quote from the project <span class="caps">README</span>:</p>
<blockquote>
<p>It is basically a direct exchange, with the exception that, instead of each consumer bound to that exchange with the same routing key getting a copy of the message, the exchange type randomly selects a queue to route to.</p>
</blockquote>
<p>This plugin is licensed under <a href="http://www.mozilla.org/MPL/MPL-1.1.html">Mozilla Public License 1.1</a>, same as RabbitMQ.</p>
<h3>x-recent-history</h3>
<p>The <a href="https://github.com/videlalvaro/rabbitmq-recent-history-exchange">x-recent-history <span class="caps">AMQP</span> exchange type</a> is a customer exchange type implemented as a RabbitMQ plugin by Alvaro Videla, one of the authors of <a href="http://bit.ly/rabbitmq">RabbitMQ in action</a>.</p>
<p>This plugin is licensed under the <a href="https://github.com/videlalvaro/rabbitmq-recent-history-exchange/blob/master/LICENSE.md"><span class="caps">MIT</span> license</a>.</p>
<h2>Using the Publisher Confirms extension to <span class="caps">AMQP</span> v0.9.1</h2>
<p>Please refer to <a href="/articles/broker_specific_extensions/">Vendor-specific extensions to <span class="caps">AMQP</span> 0.9.1 spec</a></p>
<h3>Message acknowledgements and their relationship to transactions and publisher confirms</h3>
<p>Consumer applications (applications that receive and process messages) may occasionally fail to process individual messages, or might just crash. Additionally, network issues might be experienced. This raises a question &#8211; &#8220;when should the <span class="caps">AMQP</span> broker remove messages from queues?&#8221; This topic is covered in depth in the <a href="/articles/working_with_queues/">Working With Queues</a> guide, including prefetching and examples.</p>
<p>In this guide, we will only mention how message acknowledgements are related to <span class="caps">AMQP</span> transactions and the Publisher Confirms extension. Let us consider a publisher application (P) that communications with a consumer &#169; using <span class="caps">AMQP</span> v0.9.1. Their communication can be graphically represented like this:</p>
<p><code>
-----       -----       -----
|   |   S1  |   |   S2  |   |
| P | ====&gt; | B | ====&gt; | C |
|   |       |   |       |   |
-----       -----       -----
</code></p>
<p>We have two network segments, S1 and S2. Each of them may fail. P is concerned with making sure that messages cross S1, while the broker (B) and C are concerned with ensuring that messages cross S2 and are only removed from the queue when they are processed successfully.</p>
<p>Message acknowledgements cover reliable delivery over S2 as well as successful processing. For S1, P has to use transactions (a heavyweight solution) or the more lightweight Publisher Confirms, a RabbitMQ-specific extension.</p>
<h2>Using <span class="caps">AMQP</span> transactions</h2>
<p><span class="caps">TBD</span></p>
<h2>Binding queues to exchanges</h2>
<p>Queues are bound to exchanges using the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#bind-instance_method"><span class="caps">AMQP</span>::Queue#bind</a> method. This topic is described in detail in the <a href="/articles/working_with_queues/">Working with queues</a> documentation guide.</p>
<h2>Unbinding queues from exchanges</h2>
<p>Queues are unbound from exchanges using the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#unbind-instance_method"><span class="caps">AMQP</span>::Queue#unbind</a> method. This topic is described in detail in the <a href="/articles/working_with_queues/">Working with queues</a> documentation guide.</p>
<h2>Deleting exchange</h2>
<h3>Explicitly deleting an exchange</h3>
<p>Exchanges are deleted using the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#delete-instance_method"><span class="caps">AMQP</span>::Exchange#delete</a> method:</p>
<pre>exchange.delete</pre>
<p><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange#delete-instance_method"><span class="caps">AMQP</span>::Exchange#delete</a> takes an optional callback that is run when a `exchange.delete-ok` reply arrives from the broker.</p>
<pre>exchange.delete do |delete_ok|
  # by now exchange is guaranteed to be deleted
end</pre>
<h3>Auto-deleted exchanges</h3>
<p>Exchanges can be <strong>auto-deleted</strong>. To declare an exchange as auto-deleted, use the &#8220;:auto_delete&#8221; option on declaration:</p>
<pre>exchange = AMQP::Exchange.new(channel, :direct, "nodes.metadata", :auto_delete =&gt; true)</pre>

<pre>exchange = channel.direct("nodes.metadata", :auto_delete =&gt; true)</pre>
<p>Full example:</p>
<pre>require 'amqp'


puts "=&gt; Exchange#initialize example that uses :auto_delete =&gt; true"
puts
AMQP.start(:host =&gt; 'localhost', :port =&gt; 5673) do |connection|
  AMQP::Channel.new do |channel, open_ok|
    puts "Channel ##{channel.id} is now open!"

    AMQP::Exchange.new(channel, :direct, "amqpgem.examples.xchange2", :auto_delete =&gt; false) do |exchange|
      puts "#{exchange.name} is ready to go"
    end

    AMQP::Exchange.new(channel, :direct, "amqpgem.examples.xchange3", :auto_delete =&gt; true) do |exchange|
      puts "#{exchange.name} is ready to go"
    end
  end

  show_stopper = Proc.new do
    $stdout.puts "Stopping..."
    connection.close { EventMachine.stop }
  end

  Signal.trap "INT", show_stopper
  EM.add_timer(2, show_stopper)
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1020226">gist</a>)</span></p>
<p><span class="caps">TBD</span>: explain when exchange is considered to be &#8220;no longer in use&#8221;</p>
<h2>Objects as message producers.</h2>
<p>Since Ruby is a genuine object-oriented language, it is important to demonstrate how the Ruby amqp gem can be integrated into rich object-oriented code. This part of the guide focuses on exchanges and the problems/solutions concerning producer applications (applications that primarily generate and publish messages, as opposed to consumers that receive and process them).</p>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

class Consumer

  #
  # API
  #

  def initialize(channel, queue_name = AMQ::Protocol::EMPTY_STRING)
    @queue_name = queue_name

    @channel    = channel
    @channel.on_error(&amp;method(:handle_channel_exception))
  end # initialize

  def start
    @queue = @channel.queue(@queue_name, :exclusive =&gt; true)
    @queue.subscribe(&amp;method(:handle_message))
  end # start



  #
  # Implementation
  #

  def handle_message(metadata, payload)
    puts "Received a message: #{payload}, content_type = #{metadata.content_type}"
  end # handle_message(metadata, payload)

  def handle_channel_exception(channel, channel_close)
    puts "Oops... a channel-level exception: code = #{channel_close.reply_code}, message = #{channel_close.reply_text}"
  end # handle_channel_exception(channel, channel_close)
end


class Producer

  #
  # API
  #

  def initialize(channel, exchange)
    @channel  = channel
    @exchange = exchange
  end # initialize(channel, exchange)

  def publish(message, options = {})
    @exchange.publish(message, options)
  end # publish(message, options = {})
end


AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel  = AMQP::Channel.new(connection)
  worker   = Consumer.new(channel, "amqpgem.objects.integration")
  worker.start

  producer = Producer.new(channel, channel.default_exchange)
  puts "Publishing..."
  producer.publish("Hello, world", :routing_key =&gt; "amqpgem.objects.integration")

  # stop in 2 seconds
  EventMachine.add_timer(2.0) { connection.close { EventMachine.stop } }
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1009425">gist</a>)</span></p>
<p><span class="caps">TBD</span></p>
<h2>Exchange durability vs Message durability</h2>
<p>See <a href="/articles/durability/">Durability guide</a></p>
<h2>Error handling and recovery</h2>
<p>See <a href="/articles/error_handling/">Error handling and recovery guide</a></p>
<h2>Vendor-specific extensions related to exchanges</h2>
<p>See <a href="/articles/broker_specific_extensions/">Vendor-specific Extensions guide</a></p>
<h2>What to read next</h2>
<p>Documentation is organized as several <a href="/">documentation guides</a> that cover all kinds of topics. Guides related to this one are</p>
<ul>
	<li><a href="/articles/durability/">Durability and message persistence</a></li>
	<li><a href="/articles/bindings/">Bindings</a></li>
	<li><a href="/articles/patterns_and_use_cases/">Patterns and Use Cases</a></li>
	<li><a href="/articles/working_with_queues/">Working With Queues</a></li>
	<li><a href="/articles/error_handling/">Error handling and recovery</a></li>
</ul>
<h2>Authors</h2>
This guide was written by
<a href='http://twitter.com/michaelklishin'>
  Michael Klishin
</a>
and edited by
<a href='https://twitter.com/celldee'>
  Chris Duncan
</a>
<h2>Tell us what you think!</h2>
<p>
  Please take a moment to tell us what you think about this guide
  <a href='http://twitter.com/rubyamqp'>
    on Twitter
  </a>
  or the
  <a href='http://groups.google.com/group/ruby-amqp.'>
    Ruby AMQP mailing list
  </a>
</p>
<p>
  Let us know what was unclear or what has not been covered. Maybe you do not like the guide style or grammar or discover spelling mistakes. Reader feedback is key to making the documentation better.
</p>
<p>
  If, for some reason, you cannot use the communication channels mentioned above, you can
  <a href='mailto:michaelklishin@me.com?subject=amqp%20gem%20documentation'>
    contact the author of the guides directly
  </a>
</p>
<div id='disqus_thread'></div>
<script type='text/javascript'>
  //<![CDATA[
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'rubyamqpdocs'; // required: replace example with your forum shortname
    
    var disqus_developer = 0; // set to 1 on local machine for testing comments
    = "var disqus_identifier = 'amqp_exchanges';"
    = "var disqus_url = 'http://rdoc.info/github/ruby-amqp/amqp/master/file/docs/Exchanges.textile';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  //]]>
</script></article></section></body></html>